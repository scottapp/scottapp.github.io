(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{127:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return f}));var r=n(0),a=n.n(r);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function p(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=a.a.createContext({}),s=function(e){var t=a.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):p(p({},t),e)),n},u=function(e){var t=s(e.components);return a.a.createElement(l.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},d=a.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),u=s(n),d=r,f=u["".concat(i,".").concat(d)]||u[d]||b[d]||o;return n?a.a.createElement(f,p(p({ref:t},l),{},{components:n})):a.a.createElement(f,p({ref:t},l))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var p={};for(var c in t)hasOwnProperty.call(t,c)&&(p[c]=t[c]);p.originalType=e,p.mdxType="string"==typeof e?e:r,i[1]=p;for(var l=2;l<o;l++)i[l]=n[l];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},203:function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/406_GAN_3_0-515d0fc2f259c526840c600e66938c3d.png"},204:function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/406_GAN_6_0-699e6e5a1adfae1ac1718d922a1dee9f.png"},205:function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/406_GAN_6_1-2c74d2fa640e9b9a02caa845b6d2bc21.png"},206:function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/406_GAN_6_2-058478317d3f23ef99450cf7eb7c4ee6.png"},207:function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/406_GAN_6_3-43e13d41a0c253371a32c5f8320062ed.png"},208:function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/406_GAN_6_4-9ef6bebe3006377fd85165a16a57aac5.png"},209:function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/406_GAN_6_5-293fbeefb62489afcd06d9515a87379a.png"},210:function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/406_GAN_6_6-01423d73b9e1b6ce0f0fa422710d5e51.png"},211:function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/406_GAN_6_7-ac8d9038a728e45aa8708618d6882062.png"},212:function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/406_GAN_6_8-7cbf4670cb456f3cd507252adba791d7.png"},213:function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/406_GAN_6_9-7a383b6ba66c5fc4038caf0af9ab4909.png"},90:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return p})),n.d(t,"toc",(function(){return c})),n.d(t,"default",(function(){return s}));var r=n(3),a=n(7),o=(n(0),n(127)),i={title:"406 GAN"},p={unversionedId:"ai/Docker-PyTorch-Tutorial/406_GAN",id:"ai/Docker-PyTorch-Tutorial/406_GAN",isDocsHomePage:!1,title:"406 GAN",description:"View more, visit my tutorial page//mofanpy.com/tutorials/",source:"@site/docs/ai/Docker-PyTorch-Tutorial/406_GAN.md",slug:"/ai/Docker-PyTorch-Tutorial/406_GAN",permalink:"/docs/ai/Docker-PyTorch-Tutorial/406_GAN",version:"current",sidebar:"AI",previous:{title:"405 DQN Reinforcement Learning",permalink:"/docs/ai/Docker-PyTorch-Tutorial/405_DQN_Reinforcement_learning"},next:{title:"501 Why Torch Dynamic Graph",permalink:"/docs/ai/Docker-PyTorch-Tutorial/501_why_torch_dynamic_graph"}},c=[],l={toc:c};function s(e){var t=e.components,i=Object(a.a)(e,["components"]);return Object(o.b)("wrapper",Object(r.a)({},l,i,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"View more, visit my tutorial page: ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://mofanpy.com/tutorials/"}),"https://mofanpy.com/tutorials/"),"\nMy Youtube Channel: ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://www.youtube.com/user/MorvanZhou"}),"https://www.youtube.com/user/MorvanZhou")),Object(o.b)("p",null,"Dependencies:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"torch: 0.1.11"),Object(o.b)("li",{parentName:"ul"},"numpy"),Object(o.b)("li",{parentName:"ul"},"matplotlib")),Object(o.b)("p",null,"Note: Below cells only work for pytorch version lower than 1.5, if you are using pytorch 1.5 or higher, then you will get in place error when you run For loop for Step(10000). Fixed version has been added below."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"import torch\nimport torch.nn as nn\nfrom torch.autograd import Variable\nimport numpy as np\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\ntorch.manual_seed(1)    # reproducible\nnp.random.seed(1)\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"# Hyper Parameters\nBATCH_SIZE = 64\nLR_G = 0.0001           # learning rate for generator\nLR_D = 0.0001           # learning rate for discriminator\nN_IDEAS = 5             # think of this as number of ideas for generating an art work (Generator)\nART_COMPONENTS = 15     # it could be total point G can draw in the canvas\nPAINT_POINTS = np.vstack([np.linspace(-1, 1, ART_COMPONENTS) for _ in range(BATCH_SIZE)])\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"# show our beautiful painting range\nplt.plot(PAINT_POINTS[0], 2 * np.power(PAINT_POINTS[0], 2) + 1, c='#74BCFF', lw=3, label='upper bound')\nplt.plot(PAINT_POINTS[0], 1 * np.power(PAINT_POINTS[0], 2) + 0, c='#FF9359', lw=3, label='lower bound')\nplt.legend(loc='upper right')\nplt.show()\n")),Object(o.b)("p",null,Object(o.b)("img",{alt:"png",src:n(203).default})),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"def artist_works():     # painting from the famous artist (real target)\n    a = np.random.uniform(1, 2, size=BATCH_SIZE)[:, np.newaxis]\n    paintings = a * np.power(PAINT_POINTS, 2) + (a-1)\n    paintings = torch.from_numpy(paintings).float()\n    return Variable(paintings)\n\nG = nn.Sequential(                      # Generator\n    nn.Linear(N_IDEAS, 128),            # random ideas (could from normal distribution)\n    nn.ReLU(),\n    nn.Linear(128, ART_COMPONENTS),     # making a painting from these random ideas\n)\n\nD = nn.Sequential(                      # Discriminator\n    nn.Linear(ART_COMPONENTS, 128),     # receive art work either from the famous artist or a newbie like G\n    nn.ReLU(),\n    nn.Linear(128, 1),\n    nn.Sigmoid(),                       # tell the probability that the art work is made by artist\n)\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"opt_D = torch.optim.Adam(D.parameters(), lr=LR_D)\nopt_G = torch.optim.Adam(G.parameters(), lr=LR_G)\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"for step in range(10000):\n    artist_paintings = artist_works()           # real painting from artist\n    G_ideas = Variable(torch.randn(BATCH_SIZE, N_IDEAS))    # random ideas\n    G_paintings = G(G_ideas)                    # fake painting from G (random ideas)\n\n    prob_artist0 = D(artist_paintings)          # D try to increase this prob\n    prob_artist1 = D(G_paintings)               # D try to reduce this prob\n\n    D_loss = - torch.mean(torch.log(prob_artist0) + torch.log(1. - prob_artist1))\n    G_loss = torch.mean(torch.log(1. - prob_artist1))\n\n    opt_D.zero_grad()\n    D_loss.backward(retain_variables=True)      # retain_variables for reusing computational graph\n    opt_D.step()\n\n    opt_G.zero_grad()\n    G_loss.backward()\n    opt_G.step()\n\n    if step % 1000 == 0:  # plotting\n        plt.cla()\n        plt.plot(PAINT_POINTS[0], G_paintings.data.numpy()[0], c='#4AD631', lw=3, label='Generated painting',)\n        plt.plot(PAINT_POINTS[0], 2 * np.power(PAINT_POINTS[0], 2) + 1, c='#74BCFF', lw=3, label='upper bound')\n        plt.plot(PAINT_POINTS[0], 1 * np.power(PAINT_POINTS[0], 2) + 0, c='#FF9359', lw=3, label='lower bound')\n        plt.text(-.5, 2.3, 'D accuracy=%.2f (0.5 for D to converge)' % prob_artist0.data.numpy().mean(), fontdict={'size': 15})\n        plt.text(-.5, 2, 'D score= %.2f (-1.38 for G to converge)' % -D_loss.data.numpy(), fontdict={'size': 15})\n        plt.ylim((0, 3));plt.legend(loc='upper right', fontsize=12);plt.draw();plt.pause(0.01)\n        plt.show()\n")),Object(o.b)("p",null,Object(o.b)("img",{alt:"png",src:n(204).default})),Object(o.b)("p",null,Object(o.b)("img",{alt:"png",src:n(205).default})),Object(o.b)("p",null,Object(o.b)("img",{alt:"png",src:n(206).default})),Object(o.b)("p",null,Object(o.b)("img",{alt:"png",src:n(207).default})),Object(o.b)("p",null,Object(o.b)("img",{alt:"png",src:n(208).default})),Object(o.b)("p",null,Object(o.b)("img",{alt:"png",src:n(209).default})),Object(o.b)("p",null,Object(o.b)("img",{alt:"png",src:n(210).default})),Object(o.b)("p",null,Object(o.b)("img",{alt:"png",src:n(211).default})),Object(o.b)("p",null,Object(o.b)("img",{alt:"png",src:n(212).default})),Object(o.b)("p",null,Object(o.b)("img",{alt:"png",src:n(213).default})),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"# below is for pytorch version => 1.5\n# this fix is done by albanD - https://github.com/pytorch/pytorch/issues/39141\n\nfor step in range(10000):\n    \n    artist_paintings = artist_works()           # real painting from artist\n    G_ideas = torch.randn(BATCH_SIZE, N_IDEAS, requires_grad=True)  # random ideas\n    G_paintings = G(G_ideas)                    # fake painting from G (random ideas)\n\n    prob_artist1 = D(G_paintings)               # D try to reduce this prob\n    \n    G_loss = torch.mean(torch.log(1. - prob_artist1))  \n    opt_G.zero_grad()\n    G_loss.backward()\n    opt_G.step()\n     \n    prob_artist0 = D(artist_paintings)          # D try to increase this prob\n    prob_artist1 = D(G_paintings.detach())  # D try to reduce this prob\n    D_loss = - torch.mean(torch.log(prob_artist0) + torch.log(1. - prob_artist1))      \n\n    opt_D.zero_grad()\n    D_loss.backward(retain_graph=True)      # reusing computational graph\n    opt_D.step()\n\n    if step % 1000 == 0:  # plotting\n        plt.cla()\n        plt.plot(PAINT_POINTS[0], G_paintings.data.numpy()[0], c='#4AD631', lw=3, label='Generated painting',)\n        plt.plot(PAINT_POINTS[0], 2 * np.power(PAINT_POINTS[0], 2) + 1, c='#74BCFF', lw=3, label='upper bound')\n        plt.plot(PAINT_POINTS[0], 1 * np.power(PAINT_POINTS[0], 2) + 0, c='#FF9359', lw=3, label='lower bound')\n        plt.text(-.5, 2.3, 'D accuracy=%.2f (0.5 for D to converge)' % prob_artist0.data.numpy().mean(), fontdict={'size': 15})\n        plt.text(-.5, 2, 'D score= %.2f (-1.38 for G to converge)' % -D_loss.data.numpy(), fontdict={'size': 15})\n        plt.ylim((0, 3));plt.legend(loc='upper right', fontsize=12);plt.draw();plt.pause(0.01)\n        plt.show()\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"")))}s.isMDXComponent=!0}}]);